<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>画像から文字抽出ツール（仮）</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
body {
  font-family: system-ui, sans-serif;
  background: #f7f7f7;
  padding: 20px;
  max-width: 1280px;
  margin: auto;
}
h2 {
  font-size: 1.8em;          /* ② タイトル少し大きく */
  text-align: center;       /* ② 中央寄せ */
}
.box {
  background: #fff;
  padding: 20px;
  border-radius: 10px;

  /* ★ズレ対策：canvasをCSSで縮小しない代わりに、はみ出したら横スクロール */
  overflow-x: auto;
}
canvas {
  border: 1px solid #ccc;
  cursor: crosshair;

  /* ★ズレ原因：これがあると表示だけ縮んで座標がズレるので削除 */
  /* max-width: 100%; */

  touch-action: none;
  display: none;            /* ⑤ 最初は表示しない */

  /* ついでに：余計な隙間を減らす（任意だけど安全） */
  vertical-align: top;
}
textarea {
  width: 100%;
  height: 200px;
  margin-top: 10px;
}
button {
  padding: 12px 24px;       /* ③ ボタン文字を大きく */
  margin-top: 10px;
  font-size: 1.1em;
}
#ocrBtn {
  font-weight: bold;        /* ③ 抽出ボタンのみ太字 */
}
.buttons {
  display: flex;
  gap: 10px;
}
</style>
</head>

<body>
<h2>画像から文字抽出ツール（仮）</h2>

<div class="box">
  <input type="file" id="fileInput" accept="image/*"><br><br>

  <canvas id="canvas"></canvas>

  <p>
    ・ドラッグなし → 全体OCR(全体の文字を読み取り)<br>
    ・ドラッグあり → 選択範囲OCR(選択範囲で文字を読み取り)<br>
    ・右クリック / 2本指タッチ → 赤枠を消去
  </p>

  <div class="buttons">
    <button id="ocrBtn">文字を抽出する</button>
    <button id="resetBtn">リセット</button>
  </div>

  <textarea id="result" placeholder="ここに抽出結果が表示されます"></textarea>
</div>

<script>
const OCR_ENDPOINT = "https://ocr-proxy-773716506088.asia-northeast1.run.app/ocr";

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const input = document.getElementById("fileInput");
const result = document.getElementById("result");

const MAX_W = 1200;
const MAX_H = 800;

let img = new Image();
let imgLoaded = false;
let scale = 1;

let startX, startY, endX, endY;
let dragging = false;
let selection = null;

function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!imgLoaded) return;
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  if (selection) {
    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.strokeRect(selection.x, selection.y, selection.w, selection.h);
  }
}

input.addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    img.onload = () => {
      scale = Math.min(
        MAX_W / img.naturalWidth,
        MAX_H / img.naturalHeight,
        1
      );
      canvas.width = img.naturalWidth * scale;
      canvas.height = img.naturalHeight * scale;

      canvas.style.display = "block";   /* ⑤ 読み込み後に表示 */
      imgLoaded = true;
      selection = null;
      redraw();
    };
    img.src = reader.result;
  };
  reader.readAsDataURL(file);
});

function getPos(e) {
  const r = canvas.getBoundingClientRect();
  const p = e.touches ? e.touches[0] : e;
  return { x: p.clientX - r.left, y: p.clientY - r.top };
}

function startDrag(e) {
  if (!imgLoaded) return;
  e.preventDefault();
  selection = null;          /* ① 新しい枠開始時に前の枠を消す */
  redraw();
  const p = getPos(e);
  startX = p.x;
  startY = p.y;
  dragging = true;
}

function moveDrag(e) {
  if (!dragging) return;
  e.preventDefault();
  const p = getPos(e);
  endX = p.x;
  endY = p.y;

  redraw();
  ctx.strokeStyle = "red";
  ctx.lineWidth = 2;
  ctx.strokeRect(startX, startY, endX - startX, endY - startY);
}

function endDrag(e) {
  if (!dragging) return;
  e.preventDefault();
  dragging = false;

  selection = {
    x: Math.min(startX, endX),
    y: Math.min(startY, endY),
    w: Math.abs(endX - startX),
    h: Math.abs(endY - startY)
  };
  redraw();
}

function clearSelection() {
  selection = null;
  redraw();
}

/* PC右クリック */
canvas.addEventListener("contextmenu", e => {
  e.preventDefault();
  clearSelection();
});

/* スマホ2本指タッチ */
canvas.addEventListener("touchstart", e => {
  if (e.touches.length === 2) {
    e.preventDefault();
    clearSelection();
  }
}, { passive:false });

canvas.addEventListener("mousedown", startDrag);
canvas.addEventListener("mousemove", moveDrag);
canvas.addEventListener("mouseup", endDrag);

canvas.addEventListener("touchstart", startDrag, { passive:false });
canvas.addEventListener("touchmove", moveDrag, { passive:false });
canvas.addEventListener("touchend", endDrag, { passive:false });

/* OCR */
document.getElementById("ocrBtn").onclick = async () => {
  if (!imgLoaded) return alert("画像を選択してください");

  let sx = 0, sy = 0, sw = img.naturalWidth, sh = img.naturalHeight;

  if (selection && selection.w > 5 && selection.h > 5) {
    sx = selection.x / scale;
    sy = selection.y / scale;
    sw = selection.w / scale;
    sh = selection.h / scale;
  }

  const off = document.createElement("canvas");
  off.width = sw;
  off.height = sh;
  off.getContext("2d").drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);

  const base64 = off.toDataURL("image/png").split(",")[1];
  result.value = "OCR中…";

  const res = await fetch(OCR_ENDPOINT, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ image: base64 })
  });

  const data = await res.json();
  result.value = data.text || "";
};

/* リセット（⑥ 抽出結果は消さない） */
document.getElementById("resetBtn").onclick = () => {
  imgLoaded = false;
  img.src = "";
  canvas.width = canvas.height = 0;
  canvas.style.display = "none";
  selection = null;
  input.value = "";
};
</script>
</body>
</html>
